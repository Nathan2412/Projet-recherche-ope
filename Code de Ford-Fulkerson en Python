import sys
from collections import deque

def trouver_chemin_augmentant(graphe, n, sommet_initial, sommet_arrivee, parent):
    visités = [False] * n  # Marque si un sommet a été visité
    file = deque()         # File pour le parcours en largeur

    # Initialisation : Ajoute le sommet initial à la file et le marque comme visité
    file.append(sommet_initial)
    visités[sommet_initial] = True
    parent[sommet_initial] = -1  # Aucun parent pour le sommet initial

    # Parcours en largeur
    while file:
        sommet_courant = file.popleft()  # Prend le sommet en tête de la file

        for next in range(n):  # Parcourt tous les sommets voisins
            if not visités[next] and graphe[sommet_courant][next] > 0:
                file.append(next)             # Ajoute le sommet voisin à la file
                parent[next] = sommet_courant # Enregistre le sommet courant comme parent du voisin
                visités[next] = True          # Marque le voisin comme visité
                # Si on atteint le sommet d'arrivée, on a trouvé un chemin augmentant
                if next == sommet_arrivee:
                    return True
    return False  # Aucun chemin augmentant trouvé

def ford_fulkerson(graphe, n, sommet_initial, sommet_arrivee):
    # Graphe pour stocker les capacités complémentaires
    graphe_complementaire = [ligne[:] for ligne in graphe]

    parent = [-1] * n  # Tableau pour suivre les parents dans les chemins augmentants
    flot_max = 0       # Initialisation du flot maximal à 0

    # Trouver des chemins augmentants tant qu'ils existent
    while trouver_chemin_augmentant(graphe_complementaire, n, sommet_initial, sommet_arrivee, parent):
        # Trouve la capacité minimale le long du chemin augmentant trouvé
        flot_chemin = sys.maxsize
        sommet_actuel = sommet_arrivee
        while sommet_actuel != sommet_initial:
            parent_du_sommet = parent[sommet_actuel]
            flot_chemin = min(flot_chemin, graphe_complementaire[parent_du_sommet][sommet_actuel])
            sommet_actuel = parent_du_sommet

        # Met à jour les capacités complémentaires dans le graphe
        sommet_actuel = sommet_arrivee
        while sommet_actuel != sommet_initial:
            parent_du_sommet = parent[sommet_actuel]
            graphe_complementaire[parent_du_sommet][sommet_actuel] -= flot_chemin  # Réduit la capacité sur l'arête directe
            graphe_complementaire[sommet_actuel][parent_du_sommet] += flot_chemin  # Augmente la capacité sur l'arête inverse
            sommet_actuel = parent_du_sommet

        # Ajoute le flot du chemin augmentant au flot total
        flot_max += flot_chemin

    return flot_max  # Retourne le flot maximal trouvé

def main():
    """
    Programme principal pour tester l'algorithme de Ford-Fulkerson.
    """

    # Graphe représenté par une matrice d'adjacence
    graphe = [
        [0, 16, 13, 0, 0, 0],  # Capacités des arêtes sortant du sommet 0
        [0, 0, 10, 12, 0, 0],  # Capacités des arêtes sortant du sommet 1
        [0, 4, 0, 0, 14, 0],   # Capacités des arêtes sortant du sommet 2
        [0, 0, 9, 0, 0, 20],   # Capacités des arêtes sortant du sommet 3
        [0, 0, 0, 7, 0, 4],    # Capacités des arêtes sortant du sommet 4
        [0, 0, 0, 0, 0, 0]     # Capacités des arêtes sortant du sommet 5
    ]

    n = 6               # Nombre de sommets
    sommet_initial = 0  # Sommet initial (source)
    sommet_arrivee = 5  # Sommet d'arrivée (puits)

    # Calcul du flot maximal avec Ford-Fulkerson
    flot_max = ford_fulkerson(graphe, n, sommet_initial, sommet_arrivee)
    print(f"Le flot maximal est de {flot_max}")  # Affiche le résultat

if __name__ == "__main__":
    main()
